# (C) Caimin McKenna, University College Dublin 2024
# Edited from library Generated by Kaitai with bundled.ksy file

import kaitaistruct
from kaitaistruct import KaitaiStruct, KaitaiStream, BytesIO
import numpy as np

def reverse_bits(n, no_of_bits):
    result = 0
    for i in range(no_of_bits):
        result <<= 1
        result |= n & 1
        n >>= 1
    return result


if getattr(kaitaistruct, 'API_VERSION', (0, 9)) < (0, 9):
    raise Exception("Incompatible Kaitai Struct Python API: 0.9 or later is required, but you have %s" % (kaitaistruct.__version__))

class D2a(KaitaiStruct):
    """D2A frame packet for TRANSAT flight
    
    .. seealso::
       Do NOT change anything here....
    """
    def __init__(self, _io, _parent=None, _root=None):
        self._io = _io
        self._parent = _parent
        self._root = _root if _root else self
        self._read()

    def _read(self):
        self.event = []
        i = 0
        while not self._io.is_eof():
            self.event.append(D2a.Event(self._io, self, self._root).ret)
            i += 1


    class Event(KaitaiStruct):
        """
        .. seealso::
           Source - https://wiki.wireshark.org/Development/LibpcapFileFormat#Global_Header
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            
            self.magic = self._io.read_bytes(4)
            if not self.magic == b"\xC2\x10\x00\x00":
                raise kaitaistruct.ValidationNotEqualError(b"\xC2\x10\x00\x00", self.magic, self._io, u"/types/event/seq/0")
            self.source = self._io.read_u1()
            self.pad1 = self._io.read_u2le()
            self.frametype = self._io.read_u1()
            self.ts_sub = self._io.read_u4le()
            self.ts_sec = self._io.read_u4le()
            self.ts_gps = self._io.read_u4le()
            self.event_id = self._io.read_u4le()
            self.ts_offset = self._io.read_u2le()
            self.values = []
            for i in range(17):
                self.values.append(D2a.Data(self._io, self, self._root))

            self.coincidence_window = self._io.read_u1()
            self.endpad = self._io.read_bytes(3)
            self.ret = np.array( [self.source, self.event_id, (10 * self.values[0].trigger_type) + self.pad1,  self.ts_sub, self.ts_sec , self.ts_gps, self.values[0].adc, self.values[1].adc, self.values[2].adc, self.values[3].adc, self.values[4].adc, self.values[5].adc, self.values[6].adc, self.values[7].adc, self.values[8].adc, self.values[9].adc, self.values[10].adc, self.values[11].adc, self.values[12].adc, self.values[13].adc, self.values[14].adc, self.values[15].adc, self.values[16].adc ], dtype = np.uint32)
            if not self.endpad == b"\x00\x00\x00":
                raise kaitaistruct.ValidationNotEqualError(b"\x00\x00\x00", self.endpad, self._io, u"/types/event/seq/11")


    class Data(KaitaiStruct):
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.seq_pad = self._io.read_bits_int_le(2)
            self.trigger_type = self._io.read_bits_int_le(2)
            self.adc = reverse_bits(self._io.read_bits_int_le(12), 12)
